-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
    exp = (
		fun binop (l, op, r) { Binop (op, l, r) }
		memo $ eta expr ({
        [Left, { [s("!!"), binop] , [s("&&"), binop]}],
        [Nona, { [s("<"), binop], [s("<="), binop], [s(">="), binop], [s(">"), binop], [s("=="), binop], [s("!="), binop] }],
        [Left, { [s("+"), binop], [s("-"), binop] }],
        [Left, { [s("*"), binop], [s("/"), binop], [s("%"), binop] }]
      }, primary)
	);

var stmt = memo $ eta syntax (
    cur = single s[";"] rest = stmt { Seq(cur, rest) } |
    last = single { last }
  ),
    single = memo $ eta syntax (
      v=lident s[":="] e=exp { Assn(v, e) } |
      kSkip { Skip } |
      kRead v=inbr[s("("), lident, s(")")] { Read(v) } |
      kWrite e=inbr[s("("), exp, s(")")] { Write(e) } |
      s=stmt_if{ s } |
      s=stmt_while{ s }
  ),
  stmt_if = memo $ eta syntax (
    kIf e=exp kThen s1=stmt s2=stmt_else { If(e, s1, s2) }
  ),
  stmt_else = memo $ eta syntax (
    kFi { Skip } |
    kElse s=stmt kFi { s } |
    kElif e=exp kThen s1=stmt s2=stmt_else { If(e, s1, s2) }
  ),
  stmt_while = memo $ eta syntax (
    kWhile e=exp kDo s=stmt kOd { While(e, s) } |
    kDo s=stmt kWhile e=exp kOd { DoWhile(s, e) } |
    kFor init=stmt s[","] e=exp s[","] each=stmt kDo s=stmt kOd { Seq(init, While(e, Seq(s, each))) }
  );


-- Public top-level parser
public parse = stmt;
